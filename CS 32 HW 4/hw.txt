Jake Herron 
UID: 005113997

2. The one-argument form of insert does not work for the Coord class because the one-argument insert uses comparison operators to find the correct place to insert the desired item and the Coord class does not have a comparison operator defined or overloaded to figure out how to compare it to other Coord objects. The program does not know how to compare two Coord objects and will thus return a compilation error. The two-argument insert works for the Coord class because it does not utilize comparison operators, and the single-argument insert works for ints because they have an already defined comparison operator.

4b. We could not implement the one-argument listAll as a recursive function because then we would have no way to store the path that we are on between function falls. We would have to modify the label in the vector and once we do this the domain paths for the rest of the subdomains in the vector don't make sense anymore. We would have to use a global variable in this case but that was not allowed in the constraints given in part a, so the one-parameter listAll is not implementable as a recursive function.

5a. This algorithm will have a time complexity of O(N^3) because it has 3 loops that are nested inside of each other. Each loop has a time complexity of O(N) so when they are nested together they get multiplied to be O(N^3).

5b. This algorithm will still have a time complexity of O(N^3) because we still have three for loops nested inside of each other. The outermost loop will be O(N) as it iterates N times. The next loop only iterates i times but the innermost loop iterates N times still. Because the inner loop iterates N times we could have a worst case scenario of the two inner loops together having O(N^2) or have a best case scenario of O(N). This means that the average case would be O(0.5N^2) but because we are ignoring high order terms, the average case is still O(N^2). This means that in total the time complexity is still O(N^3).

6a. The interleave algorithm would have a time complexity of O(N^2) because the first for loop iterates N times as k varies from 0 to N which makes it a O(N). We use the get function for each index value of k in the Sequence and that is a O(N) operation because we have to iterate through the whole linked list to get to our value. This doubles to O(2N) because we use get for both of the functions. When we combine this together we get a complexity of O(2N^2) which becomes O(N^2) when we ignore high order terms. The other for loop also iterates through N times and used the get function for linked lists N times so that is also O(N^2) but these two loops are not nested so the overall time complexity is O(N^2).

6b. The time complexity for this interleave algorithm is ony O(N) because the first for loop in this function will only iterate N times through both of our sequences. We utilized insertBefore which will put the the items in sequence of each other which makes it better than the other algorithm in part a as that one had to use get which iterated through the linked list again to find the right position. The other for loop will also have a complexity of O(N) at the worst so when we combine these together we have a complexity of O(N) which is better than that of part a because we keep track of the positions we need to insert the items as we iterate instead of needing to iterate through the list again like in part a.

